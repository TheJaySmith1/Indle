import { useState, useEffect, useCallback, useRef } from 'react';

export interface Company {
  id: string;
  name: string;
  industry: string;
  level: number;
  baseIncome: number;
  currentIncome: number;
  upgradeCost: number;
  marketValue: number;
  sharesOwned: number; // Percentage (0-100)
  lastUpdate: number;
  description: string;
  icon: string;
  isReal?: boolean;
  // Box office specific
  totalBoxOfficeEarnings?: number;
  moviesProduced?: number;
  lastBoxOfficeHit?: number;
  lastProjectStart?: number;
}

export interface RealCompany {
  id: string;
  name: string;
  industry: string;
  marketValue: number;
  sharesOwned: number;
  description: string;
  ticker: string;
  logo: string;
  baseIncome: number;
  currentIncome: number;
  lastUpdate: number;
  volatility: number; // How much the price fluctuates
  isReal: true;
}

export interface Loan {
  id: string;
  amount: number;
  originalAmount: number;
  interestRate: number; // Annual rate as decimal (0.05 = 5%)
  monthlyPayment: number;
  remainingPayments: number;
  totalPayments: number;
  takenDate: number;
  lastPaymentDate: number;
  missedPayments: number;
  loanType: 'small' | 'medium' | 'large' | 'emergency';
  status: 'active' | 'paid' | 'defaulted';
}

export interface BoxOfficeProject {
  id: string;
  companyId: string;
  title: string;
  type: 'movie' | 'series' | 'documentary';
  budget: number;
  releaseDate: number;
  status: 'in-production' | 'released' | 'completed';
  grossEarnings: number;
  productionTime: number; // in seconds
  genre: string;
  isAutoGenerated?: boolean;
}

export interface AutoBoxOfficeSettings {
  enabled: boolean;
  minCashReserve: number; // Minimum cash to keep before auto-investing
  maxInvestmentPercentage: number; // Max % of cash to invest per project
  preferredProjectType: 'movie' | 'series' | 'documentary' | 'auto';
  aggressiveness: 'conservative' | 'balanced' | 'aggressive'; // How much to invest
}

export interface GameState {
  cash: number;
  totalNetWorth: number;
  companies: Company[];
  realCompanies: RealCompany[];
  loans: Loan[];
  boxOfficeProjects: BoxOfficeProject[];
  autoBoxOfficeSettings: AutoBoxOfficeSettings;
  creditScore: number; // 300-850 scale
  lastSave: number;
  saveVersion: string;
  playTime: number; // Total play time in seconds
}

export interface SaveSlot {
  id: string;
  name: string;
  gameState: GameState;
  createdAt: number;
  lastPlayed: number;
  playTime: number;
  companies: number;
  netWorth: number;
}

export interface Industry {
  id: string;
  name: string;
  baseIncome: number;
  baseCost: number;
  description: string;
  icon: string;
}

export interface LoanOffer {
  type: 'small' | 'medium' | 'large' | 'emergency';
  name: string;
  minAmount: number;
  maxAmount: number;
  baseInterestRate: number;
  termMonths: number;
  description: string;
  creditScoreRequired: number;
}

export type SaveStatus = 'saving' | 'saved' | 'error' | 'idle';
export type BoxOfficeOutcome = 'flop' | 'moderate' | 'hit' | 'blockbuster' | 'legendary';

const INDUSTRIES: Industry[] = [
  {
    id: 'coffee',
    name: 'Coffee Shop Chain',
    baseIncome: 10,
    baseCost: 100,
    description: 'Start with a small coffee shop and grow into a global chain',
    icon: '‚òï'
  },
  {
    id: 'film',
    name: 'Film & TV Production',
    baseIncome: 50,
    baseCost: 500,
    description: 'Produce blockbuster movies and hit TV shows with automated box office potential',
    icon: 'üé¨'
  },
  {
    id: 'construction',
    name: 'Construction Company',
    baseIncome: 25,
    baseCost: 250,
    description: 'Build skyscrapers and infrastructure projects',
    icon: 'üèóÔ∏è'
  },
  {
    id: 'tech',
    name: 'Tech Startup',
    baseIncome: 40,
    baseCost: 400,
    description: 'Develop cutting-edge software and apps',
    icon: 'üíª'
  },
  {
    id: 'restaurant',
    name: 'Restaurant Chain',
    baseIncome: 15,
    baseCost: 150,
    description: 'Serve delicious food to customers worldwide',
    icon: 'üçΩÔ∏è'
  },
  {
    id: 'fashion',
    name: 'Fashion Brand',
    baseIncome: 30,
    baseCost: 300,
    description: 'Design trendy clothing and accessories',
    icon: 'üëó'
  }
];

const REAL_COMPANIES: Omit<RealCompany, 'sharesOwned' | 'lastUpdate' | 'currentIncome'>[] = [
  {
    id: 'apple',
    name: 'Apple Inc.',
    ticker: 'AAPL',
    industry: 'Technology',
    marketValue: 3200000000000,
    description: 'Multinational technology company designing consumer electronics and software',
    logo: 'üçé',
    baseIncome: 15000,
    volatility: 0.03,
    isReal: true
  },
  {
    id: 'microsoft',
    name: 'Microsoft Corporation',
    ticker: 'MSFT',
    industry: 'Technology',
    marketValue: 2800000000000,
    description: 'Global technology company developing software, services, and devices',
    logo: 'ü™ü',
    baseIncome: 12000,
    volatility: 0.025,
    isReal: true
  },
  {
    id: 'tesla',
    name: 'Tesla, Inc.',
    ticker: 'TSLA',
    industry: 'Automotive',
    marketValue: 800000000000,
    description: 'Electric vehicles and clean energy company',
    logo: '‚ö°',
    baseIncome: 8000,
    volatility: 0.08,
    isReal: true
  },
  {
    id: 'amazon',
    name: 'Amazon.com, Inc.',
    ticker: 'AMZN',
    industry: 'E-commerce',
    marketValue: 1500000000000,
    description: 'E-commerce and cloud computing services giant',
    logo: 'üì¶',
    baseIncome: 10000,
    volatility: 0.04,
    isReal: true
  },
  {
    id: 'google',
    name: 'Alphabet Inc.',
    ticker: 'GOOGL',
    industry: 'Technology',
    marketValue: 1700000000000,
    description: 'Multinational technology company specializing in internet services',
    logo: 'üîç',
    baseIncome: 11000,
    volatility: 0.035,
    isReal: true
  },
  {
    id: 'netflix',
    name: 'Netflix, Inc.',
    ticker: 'NFLX',
    industry: 'Entertainment',
    marketValue: 200000000000,
    description: 'Streaming entertainment service with TV series and films',
    logo: 'üé¨',
    baseIncome: 3000,
    volatility: 0.06,
    isReal: true
  },
  {
    id: 'nike',
    name: 'Nike, Inc.',
    ticker: 'NKE',
    industry: 'Consumer Goods',
    marketValue: 180000000000,
    description: 'Global athletic footwear and apparel company',
    logo: 'üëü',
    baseIncome: 2500,
    volatility: 0.045,
    isReal: true
  },
  {
    id: 'starbucks',
    name: 'Starbucks Corporation',
    ticker: 'SBUX',
    industry: 'Food & Beverage',
    marketValue: 120000000000,
    description: 'International chain of coffeehouses and roastery reserves',
    logo: '‚òï',
    baseIncome: 2000,
    volatility: 0.05,
    isReal: true
  },
  {
    id: 'disney',
    name: 'The Walt Disney Company',
    ticker: 'DIS',
    industry: 'Entertainment',
    marketValue: 220000000000,
    description: 'Multinational entertainment and media conglomerate',
    logo: 'üè∞',
    baseIncome: 3200,
    volatility: 0.055,
    isReal: true
  }
];

const LOAN_OFFERS: LoanOffer[] = [
  {
    type: 'small',
    name: 'Small Business Loan',
    minAmount: 1000,
    maxAmount: 10000,
    baseInterestRate: 0.08, // 8%
    termMonths: 12,
    description: 'Perfect for startup capital or small expansions',
    creditScoreRequired: 500
  },
  {
    type: 'medium',
    name: 'Growth Capital Loan',
    minAmount: 10000,
    maxAmount: 100000,
    baseInterestRate: 0.06, // 6%
    termMonths: 24,
    description: 'Ideal for significant business growth and expansion',
    creditScoreRequired: 600
  },
  {
    type: 'large',
    name: 'Corporate Expansion Loan',
    minAmount: 100000,
    maxAmount: 1000000,
    baseInterestRate: 0.05, // 5%
    termMonths: 36,
    description: 'Large-scale funding for major business ventures',
    creditScoreRequired: 700
  },
  {
    type: 'emergency',
    name: 'Emergency Cash Advance',
    minAmount: 500,
    maxAmount: 5000,
    baseInterestRate: 0.15, // 15%
    termMonths: 6,
    description: 'Quick cash for urgent business needs (high interest)',
    creditScoreRequired: 400
  }
];

const MOVIE_GENRES = ['Action', 'Comedy', 'Drama', 'Horror', 'Sci-Fi', 'Romance', 'Thriller', 'Documentary', 'Animation'];
const MOVIE_TITLES = [
  'Digital Revolution', 'The Last Stand', 'Beyond Tomorrow', 'Midnight Chase', 'Silent Storm',
  'City of Dreams', 'The Final Hour', 'Lost in Time', 'Breaking Point', 'Shadow Wars',
  'New Horizons', 'The Journey Home', 'Infinite Loop', 'Star Crossed', 'Underground',
  'Empire Rising', 'Quantum Dreams', 'Golden Hour', 'Dark Waters', 'Phoenix Rising',
  'Crystal Vision', 'Thunder Road', 'Moonlight Serenade', 'Steel Hearts', 'Neon Nights'
];

const SAVE_KEY = 'entrepreneur_game_save';
const SAVE_SLOTS_KEY = 'entrepreneur_game_saves';
const CURRENT_SAVE_SLOT_KEY = 'entrepreneur_current_save_slot';
const SAVE_VERSION = '1.2.0';
const INCOME_INTERVAL = 1000; // 1 second
const AUTO_SAVE_INTERVAL = 10000; // 10 seconds
const PLAY_TIME_INTERVAL = 1000; // 1 second
const LOAN_PAYMENT_INTERVAL = 30000; // 30 seconds (represents 1 month)
const AUTO_INVESTMENT_INTERVAL = 3000; // Check every 3 seconds for auto-investment opportunities
const BOX_OFFICE_CHECK_INTERVAL = 2000; // Check every 2 seconds for completed projects

const getDefaultAutoBoxOfficeSettings = (): AutoBoxOfficeSettings => ({
  enabled: true,
  minCashReserve: 100000, // Increased to $100K to handle realistic budgets
  maxInvestmentPercentage: 0.2, // Reduced to 20% due to higher budget requirements
  preferredProjectType: 'auto',
  aggressiveness: 'balanced'
});

const getDefaultGameState = (): GameState => ({
  cash: 10000, // Increased starting cash to handle realistic budgets
  totalNetWorth: 10000,
  companies: [],
  realCompanies: REAL_COMPANIES.map(company => ({
    ...company,
    sharesOwned: 0,
    currentIncome: company.baseIncome,
    lastUpdate: Date.now()
  })),
  loans: [],
  boxOfficeProjects: [],
  autoBoxOfficeSettings: getDefaultAutoBoxOfficeSettings(),
  creditScore: 700, // Start with good credit
  lastSave: Date.now(),
  saveVersion: SAVE_VERSION,
  playTime: 0
});

export const useGameState = () => {
  const [gameState, setGameState] = useState<GameState>(() => {
    const saved = localStorage.getItem(SAVE_KEY);
    if (saved) {
      try {
        const parsedSave = JSON.parse(saved);
        // Calculate offline earnings
        const offlineTime = Date.now() - parsedSave.lastSave;
        
        const companiesOfflineEarnings = (parsedSave.companies || []).reduce((total: number, company: Company) => {
          return total + (company.currentIncome * company.sharesOwned / 100 * (offlineTime / INCOME_INTERVAL));
        }, 0);

        const realCompaniesOfflineEarnings = (parsedSave.realCompanies || []).reduce((total: number, company: RealCompany) => {
          return total + (company.currentIncome * company.sharesOwned / 100 * (offlineTime / INCOME_INTERVAL));
        }, 0);
        
        return {
          ...parsedSave,
          companies: parsedSave.companies || [],
          realCompanies: parsedSave.realCompanies || REAL_COMPANIES.map(company => ({
            ...company,
            sharesOwned: 0,
            currentIncome: company.baseIncome,
            lastUpdate: Date.now()
          })),
          loans: parsedSave.loans || [],
          boxOfficeProjects: parsedSave.boxOfficeProjects || [],
          autoBoxOfficeSettings: { ...getDefaultAutoBoxOfficeSettings(), ...(parsedSave.autoBoxOfficeSettings || {}) },
          creditScore: parsedSave.creditScore || 700,
          cash: parsedSave.cash + Math.floor(companiesOfflineEarnings + realCompaniesOfflineEarnings),
          lastSave: Date.now(),
          saveVersion: SAVE_VERSION,
          playTime: parsedSave.playTime || 0
        };
      } catch (error) {
        console.error('Failed to load save:', error);
        return getDefaultGameState();
      }
    }
    
    return getDefaultGameState();
  });

  const [saveStatus, setSaveStatus] = useState<SaveStatus>('idle');
  const [currentSaveSlot, setCurrentSaveSlot] = useState<string>('main');
  const lastSaveTimeRef = useRef<number>(Date.now());
  const playTimeStartRef = useRef<number>(Date.now());

  // Auto Box Office Functions with realistic budget handling
  const calculateOptimalBudget = useCallback((company: Company, availableCash: number, settings: AutoBoxOfficeSettings) => {
    const { aggressiveness, maxInvestmentPercentage, minCashReserve } = settings;
    
    // Ensure we don't spend below minimum cash reserve
    const investableCash = Math.max(0, availableCash - minCashReserve);
    const maxInvestment = investableCash * maxInvestmentPercentage;
    
    if (maxInvestment < 100000) return 0; // Need at least 100K to invest (minimum documentary budget)
    
    // Realistic budget calculation based on company level and available cash
    let baseBudget = 1000000; // Start with $1M (minimum movie budget)
    
    // Scale with company level - higher level companies can handle bigger budgets
    baseBudget *= Math.pow(1.5, company.level - 1);
    
    // Adjust for past performance
    const avgReturn = company.totalBoxOfficeEarnings && company.moviesProduced 
      ? company.totalBoxOfficeEarnings / company.moviesProduced 
      : baseBudget * 2.5; // Assume good return if no history
    
    if (avgReturn > baseBudget * 2) {
      baseBudget *= 1.3; // Increase budget for successful companies
    }
    
    // Apply aggressiveness multiplier
    const aggressivenessMultiplier = {
      'conservative': 0.5,
      'balanced': 1.0,
      'aggressive': 2.0
    }[aggressiveness];
    
    baseBudget *= aggressivenessMultiplier;
    
    // Cap at maximum investment but ensure realistic minimums
    const optimalBudget = Math.min(maxInvestment, baseBudget);
    
    // Choose appropriate project type based on budget
    if (optimalBudget >= 1000000) {
      return Math.max(1000000, Math.floor(optimalBudget)); // Movie budget
    } else if (optimalBudget >= 500000) {
      return Math.max(500000, Math.floor(optimalBudget)); // Series budget
    } else if (optimalBudget >= 100000) {
      return Math.max(100000, Math.floor(optimalBudget)); // Documentary budget
    }
    
    return 0; // Not enough for any realistic production
  }, []);

  const selectOptimalProjectType = useCallback((settings: AutoBoxOfficeSettings, company: Company, budget: number): 'movie' | 'series' | 'documentary' => {
    if (settings.preferredProjectType !== 'auto') {
      return settings.preferredProjectType;
    }
    
    // Auto-select based on budget and company level
    if (budget >= 10000000 && company.level >= 3) {
      return 'movie'; // Big budget movies for experienced companies
    } else if (budget >= 1000000) {
      return Math.random() < 0.7 ? 'movie' : 'series'; // Mostly movies for mid-budget
    } else if (budget >= 500000) {
      return Math.random() < 0.3 ? 'movie' : Math.random() < 0.8 ? 'series' : 'documentary'; // Prefer series
    } else {
      return 'documentary'; // Low budget = documentary
    }
  }, []);

  const shouldAutoInvest = useCallback((company: Company, settings: AutoBoxOfficeSettings, currentProjects: BoxOfficeProject[]) => {
    if (!settings.enabled) {
      console.log('Auto investment disabled');
      return false;
    }
    
    // Check if company has any active projects
    const activeProjects = currentProjects.filter(p => 
      p.companyId === company.id && p.status === 'in-production'
    );
    
    if (activeProjects.length > 0) {
      console.log(`Company ${company.name} has ${activeProjects.length} active projects, waiting...`);
      return false; // Wait for current project to finish
    }
    
    // Reduced cooldown time to 15 seconds instead of 1 minute
    const now = Date.now();
    if (company.lastProjectStart && now - company.lastProjectStart < 15000) {
      console.log(`Company ${company.name} still in cooldown period`);
      return false;
    }
    
    console.log(`Company ${company.name} is ready for auto investment`);
    return true;
  }, []);

  // Auto box office management - More realistic budget handling
  useEffect(() => {
    console.log('Setting up auto investment interval');
    const autoInvestmentInterval = setInterval(() => {
      setGameState(prev => {
        if (!prev.autoBoxOfficeSettings.enabled) {
          console.log('Auto box office disabled');
          return prev;
        }
        
        const filmCompanies = prev.companies.filter(c => c.industry === 'Film & TV Production');
        if (filmCompanies.length === 0) {
          console.log('No film companies found');
          return prev;
        }
        
        console.log(`Found ${filmCompanies.length} film companies, checking for auto-investment...`);
        
        let hasChanges = false;
        let updatedGameState = { ...prev };
        let updatedCompanies = [...prev.companies];
        let updatedProjects = [...prev.boxOfficeProjects];
        
        for (const company of filmCompanies) {
          if (!shouldAutoInvest(company, prev.autoBoxOfficeSettings, prev.boxOfficeProjects)) {
            continue;
          }
          
          const optimalBudget = calculateOptimalBudget(company, updatedGameState.cash, prev.autoBoxOfficeSettings);
          console.log(`Optimal budget for ${company.name}: $${optimalBudget}, Available cash: $${updatedGameState.cash}`);
          
          if (optimalBudget >= 100000 && updatedGameState.cash >= optimalBudget) {
            const projectType = selectOptimalProjectType(prev.autoBoxOfficeSettings, company, optimalBudget);
            const genres = MOVIE_GENRES;
            const titles = MOVIE_TITLES;
            
            const productionTime = projectType === 'movie' ? 15000 : projectType === 'series' ? 25000 : 10000; // Reduced times
            
            const newProject: BoxOfficeProject = {
              id: Date.now().toString() + Math.random().toString(36).substr(2, 9),
              companyId: company.id,
              title: titles[Math.floor(Math.random() * titles.length)],
              type: projectType,
              budget: optimalBudget,
              releaseDate: Date.now() + productionTime,
              status: 'in-production',
              grossEarnings: 0,
              productionTime: productionTime,
              genre: genres[Math.floor(Math.random() * genres.length)],
              isAutoGenerated: true
            };
            
            console.log(`üé¨ AUTO-INVESTING: ${company.name} starting ${projectType} "${newProject.title}" with budget $${optimalBudget}`);
            
            // Update cash and add project
            updatedGameState.cash -= optimalBudget;
            updatedProjects.push(newProject);
            hasChanges = true;
            
            // Update company's last project start time
            updatedCompanies = updatedCompanies.map(c => 
              c.id === company.id 
                ? { ...c, lastProjectStart: Date.now() }
                : c
            );
          } else {
            console.log(`Cannot invest: Budget too low (${optimalBudget}) or insufficient cash (${updatedGameState.cash})`);
          }
        }
        
        if (hasChanges) {
          console.log('Auto-investment changes applied');
          return {
            ...updatedGameState,
            companies: updatedCompanies,
            boxOfficeProjects: updatedProjects
          };
        }
        
        return prev;
      });
    }, AUTO_INVESTMENT_INTERVAL);

    return () => {
      console.log('Cleaning up auto investment interval');
      clearInterval(autoInvestmentInterval);
    };
  }, [calculateOptimalBudget, selectOptimalProjectType, shouldAutoInvest]);

  // Update auto box office settings
  const updateAutoBoxOfficeSettings = useCallback((newSettings: Partial<AutoBoxOfficeSettings>) => {
    console.log('Updating auto box office settings:', newSettings);
    setGameState(prev => ({
      ...prev,
      autoBoxOfficeSettings: { ...prev.autoBoxOfficeSettings, ...newSettings }
    }));
  }, []);

  // Loan and box office functions (keeping existing manual versions)
  const takeLoan = useCallback((loanType: 'small' | 'medium' | 'large' | 'emergency', amount: number) => {
    const offer = LOAN_OFFERS.find(o => o.type === loanType);
    if (!offer || amount < offer.minAmount || amount > offer.maxAmount) return false;
    
    // Credit score affects interest rate
    const creditMultiplier = Math.max(0.5, Math.min(2, (850 - gameState.creditScore) / 350));
    const adjustedRate = offer.baseInterestRate * (1 + creditMultiplier * 0.5);
    
    const monthlyPayment = amount * (adjustedRate / 12) / (1 - Math.pow(1 + adjustedRate / 12, -offer.termMonths));
    
    const newLoan: Loan = {
      id: Date.now().toString(),
      amount: amount,
      originalAmount: amount,
      interestRate: adjustedRate,
      monthlyPayment: monthlyPayment,
      remainingPayments: offer.termMonths,
      totalPayments: offer.termMonths,
      takenDate: Date.now(),
      lastPaymentDate: Date.now(),
      missedPayments: 0,
      loanType: loanType,
      status: 'active'
    };
    
    setGameState(prev => ({
      ...prev,
      cash: prev.cash + amount,
      loans: [...prev.loans, newLoan],
      creditScore: Math.max(300, prev.creditScore - 5) // Small credit hit for taking loan
    }));
    
    return true;
  }, [gameState.creditScore]);

  const repayLoan = useCallback((loanId: string, amount?: number) => {
    setGameState(prev => {
      const loan = prev.loans.find(l => l.id === loanId);
      if (!loan || loan.status !== 'active' || prev.cash < (amount || loan.monthlyPayment)) return prev;
      
      const paymentAmount = amount || loan.monthlyPayment;
      const updatedLoans = prev.loans.map(l => {
        if (l.id === loanId) {
          const newAmount = Math.max(0, l.amount - paymentAmount);
          const newRemainingPayments = Math.max(0, l.remainingPayments - 1);
          
          return {
            ...l,
            amount: newAmount,
            remainingPayments: newRemainingPayments,
            lastPaymentDate: Date.now(),
            status: newAmount === 0 ? 'paid' as const : 'active' as const
          };
        }
        return l;
      });
      
      // Credit score improvement for on-time payments
      const creditImprovement = amount && amount > loan.monthlyPayment ? 3 : 1;
      
      return {
        ...prev,
        cash: prev.cash - paymentAmount,
        loans: updatedLoans,
        creditScore: Math.min(850, prev.creditScore + creditImprovement)
      };
    });
  }, []);

  const startBoxOfficeProject = useCallback((companyId: string, budget: number, projectType: 'movie' | 'series' | 'documentary') => {
    const company = gameState.companies.find(c => c.id === companyId);
    if (!company || company.industry !== 'Film & TV Production' || gameState.cash < budget) return false;
    
    const genres = MOVIE_GENRES;
    const titles = MOVIE_TITLES;
    
    const productionTime = projectType === 'movie' ? 15000 : projectType === 'series' ? 25000 : 10000;
    
    const newProject: BoxOfficeProject = {
      id: Date.now().toString(),
      companyId: companyId,
      title: titles[Math.floor(Math.random() * titles.length)],
      type: projectType,
      budget: budget,
      releaseDate: Date.now() + productionTime,
      status: 'in-production',
      grossEarnings: 0,
      productionTime: productionTime,
      genre: genres[Math.floor(Math.random() * genres.length)],
      isAutoGenerated: false
    };
    
    setGameState(prev => ({
      ...prev,
      cash: prev.cash - budget,
      boxOfficeProjects: [...prev.boxOfficeProjects, newProject],
      companies: prev.companies.map(c => 
        c.id === companyId ? { ...c, lastProjectStart: Date.now() } : c
      )
    }));
    
    return true;
  }, [gameState.cash, gameState.companies]);

  const calculateBoxOfficeOutcome = (project: BoxOfficeProject, company: Company): { outcome: BoxOfficeOutcome; multiplier: number; earnings: number } => {
    // Base success chance influenced by company level and budget
    let successChance = 0.4 + (company.level * 0.08) + Math.min(0.4, project.budget / 50000000); // Scale with realistic budgets
    
    // Auto-generated projects get significant bonus for optimal budgeting
    if (project.isAutoGenerated) {
      successChance += 0.2;
    }
    
    const random = Math.random();
    let outcome: BoxOfficeOutcome;
    let multiplier: number;
    
    if (random < 0.08) {
      outcome = 'legendary';
      multiplier = 12 + Math.random() * 8; // 12-20x
    } else if (random < 0.25) {
      outcome = 'blockbuster';
      multiplier = 6 + Math.random() * 4; // 6-10x
    } else if (random < 0.55) {
      outcome = 'hit';
      multiplier = 2.5 + Math.random() * 2.5; // 2.5-5x
    } else if (random < 0.85) {
      outcome = 'moderate';
      multiplier = 1 + Math.random() * 1; // 1-2x
    } else {
      outcome = 'flop';
      multiplier = 0.2 + Math.random() * 0.5; // 0.2-0.7x
    }
    
    const earnings = Math.floor(project.budget * multiplier);
    return { outcome, multiplier, earnings };
  };

  // Auto-save functionality
  const performSave = useCallback((state?: GameState, slotId?: string) => {
    const stateToSave = state || gameState;
    const targetSlot = slotId || currentSaveSlot;
    
    try {
      setSaveStatus('saving');
      
      // Save current game state
      localStorage.setItem(SAVE_KEY, JSON.stringify({
        ...stateToSave,
        lastSave: Date.now()
      }));
      
      // Save to specific slot
      const existingSaves = localStorage.getItem(SAVE_SLOTS_KEY);
      const saveSlots: SaveSlot[] = existingSaves ? JSON.parse(existingSaves) : [];
      
      const saveSlot: SaveSlot = {
        id: targetSlot,
        name: targetSlot === 'main' ? 'Main Save' : `Save ${targetSlot}`,
        gameState: { ...stateToSave, lastSave: Date.now() },
        createdAt: saveSlots.find(s => s.id === targetSlot)?.createdAt || Date.now(),
        lastPlayed: Date.now(),
        playTime: stateToSave.playTime,
        companies: stateToSave.companies.length,
        netWorth: stateToSave.totalNetWorth
      };
      
      const updatedSlots = saveSlots.filter(s => s.id !== targetSlot);
      updatedSlots.push(saveSlot);
      
      localStorage.setItem(SAVE_SLOTS_KEY, JSON.stringify(updatedSlots));
      localStorage.setItem(CURRENT_SAVE_SLOT_KEY, targetSlot);
      
      setSaveStatus('saved');
      lastSaveTimeRef.current = Date.now();
      
      setTimeout(() => setSaveStatus('idle'), 2000);
    } catch (error) {
      console.error('Save failed:', error);
      setSaveStatus('error');
      setTimeout(() => setSaveStatus('idle'), 3000);
    }
  }, [gameState, currentSaveSlot]);

  // Auto-save every 10 seconds
  useEffect(() => {
    const saveInterval = setInterval(() => {
      performSave();
    }, AUTO_SAVE_INTERVAL);

    return () => clearInterval(saveInterval);
  }, [performSave]);

  // Play time tracking
  useEffect(() => {
    const playTimeInterval = setInterval(() => {
      setGameState(prev => ({
        ...prev,
        playTime: prev.playTime + 1
      }));
    }, PLAY_TIME_INTERVAL);

    return () => clearInterval(playTimeInterval);
  }, []);

  // Loan payment processing
  useEffect(() => {
    const loanInterval = setInterval(() => {
      setGameState(prev => {
        const now = Date.now();
        const updatedLoans = prev.loans.map(loan => {
          if (loan.status === 'active' && now - loan.lastPaymentDate >= LOAN_PAYMENT_INTERVAL) {
            // Check if player can afford payment
            if (prev.cash >= loan.monthlyPayment) {
              // Auto-pay if enough cash
              const newAmount = Math.max(0, loan.amount - loan.monthlyPayment);
              return {
                ...loan,
                amount: newAmount,
                remainingPayments: Math.max(0, loan.remainingPayments - 1),
                lastPaymentDate: now,
                status: newAmount === 0 ? 'paid' as const : 'active' as const
              };
            } else {
              // Miss payment - credit score hit
              return {
                ...loan,
                missedPayments: loan.missedPayments + 1,
                lastPaymentDate: now
              };
            }
          }
          return loan;
        });

        const missedPayments = updatedLoans.filter(l => l.missedPayments > 0).length;
        const creditPenalty = missedPayments * 10;
        const newCreditScore = Math.max(300, prev.creditScore - creditPenalty);

        // Calculate loan payments
        const totalLoanPayments = updatedLoans.reduce((total, loan) => {
          if (loan.status === 'active' && now - loan.lastPaymentDate >= LOAN_PAYMENT_INTERVAL && prev.cash >= loan.monthlyPayment) {
            return total + loan.monthlyPayment;
          }
          return total;
        }, 0);

        return {
          ...prev,
          cash: Math.max(0, prev.cash - totalLoanPayments),
          loans: updatedLoans,
          creditScore: newCreditScore
        };
      });
    }, LOAN_PAYMENT_INTERVAL);

    return () => clearInterval(loanInterval);
  }, []);

  // Box office project completion (auto-release) - More frequent checks
  useEffect(() => {
    console.log('Setting up box office completion interval');
    const boxOfficeInterval = setInterval(() => {
      setGameState(prev => {
        const now = Date.now();
        let hasCompletions = false;
        
        const updatedProjects = prev.boxOfficeProjects.map(project => {
          if (project.status === 'in-production' && now >= project.releaseDate) {
            const company = prev.companies.find(c => c.id === project.companyId);
            if (company) {
              const { outcome, earnings } = calculateBoxOfficeOutcome(project, company);
              console.log(`üé≠ AUTO-RELEASE: "${project.title}" earned $${earnings} (${outcome})`);
              hasCompletions = true;
              return {
                ...project,
                status: 'released' as const,
                grossEarnings: earnings
              };
            }
          }
          return project;
        });

        if (!hasCompletions) return prev;

        // Calculate new box office earnings
        const newEarnings = updatedProjects
          .filter(p => p.status === 'released')
          .reduce((total, project) => {
            const oldProject = prev.boxOfficeProjects.find(p => p.id === project.id);
            return total + (oldProject?.status === 'in-production' ? project.grossEarnings : 0);
          }, 0);

        // Update company stats
        const updatedCompanies = prev.companies.map(company => {
          const completedProjects = updatedProjects.filter(p => 
            p.companyId === company.id && p.status === 'released'
          );
          
          if (completedProjects.length > 0) {
            const totalBoxOffice = completedProjects.reduce((sum, p) => sum + p.grossEarnings, 0);
            return {
              ...company,
              totalBoxOfficeEarnings: totalBoxOffice,
              moviesProduced: completedProjects.length,
              lastBoxOfficeHit: completedProjects[completedProjects.length - 1]?.releaseDate || company.lastBoxOfficeHit
            };
          }
          return company;
        });

        console.log(`üí∞ AUTO-EARNINGS: Added $${newEarnings} to cash reserves`);

        return {
          ...prev,
          cash: prev.cash + newEarnings,
          boxOfficeProjects: updatedProjects,
          companies: updatedCompanies
        };
      });
    }, BOX_OFFICE_CHECK_INTERVAL);

    return () => {
      console.log('Cleaning up box office completion interval');
      clearInterval(boxOfficeInterval);
    };
  }, []);

  // Income generation
  useEffect(() => {
    const incomeInterval = setInterval(() => {
      setGameState(prev => {
        const companiesIncome = prev.companies.reduce((total, company) => {
          return total + (company.currentIncome * company.sharesOwned / 100);
        }, 0);

        const realCompaniesIncome = prev.realCompanies.reduce((total, company) => {
          return total + (company.currentIncome * company.sharesOwned / 100);
        }, 0);
        
        // Update market values with volatility for regular companies
        const updatedCompanies = prev.companies.map(company => ({
          ...company,
          marketValue: Math.max(100, company.marketValue * (0.98 + Math.random() * 0.04)),
          lastUpdate: Date.now()
        }));

        // Update real companies with their specific volatility
        const updatedRealCompanies = prev.realCompanies.map(company => ({
          ...company,
          marketValue: Math.max(company.marketValue * 0.1, company.marketValue * (1 - company.volatility + Math.random() * company.volatility * 2)),
          lastUpdate: Date.now()
        }));

        const newCash = prev.cash + companiesIncome + realCompaniesIncome;
        const companiesNetWorth = updatedCompanies.reduce((total, company) => 
          total + (company.marketValue * company.sharesOwned / 100), 0
        );
        const realCompaniesNetWorth = updatedRealCompanies.reduce((total, company) => 
          total + (company.marketValue * company.sharesOwned / 100), 0
        );
        const totalNetWorth = newCash + companiesNetWorth + realCompaniesNetWorth;

        return {
          ...prev,
          cash: newCash,
          totalNetWorth,
          companies: updatedCompanies,
          realCompanies: updatedRealCompanies
        };
      });
    }, INCOME_INTERVAL);

    return () => clearInterval(incomeInterval);
  }, []);

  // Save management functions (keeping existing ones)
  const manualSave = useCallback((slotId?: string) => {
    performSave(gameState, slotId);
  }, [performSave, gameState]);

  const loadSave = useCallback((slotId: string) => {
    try {
      const existingSaves = localStorage.getItem(SAVE_SLOTS_KEY);
      if (!existingSaves) return false;
      
      const saveSlots: SaveSlot[] = JSON.parse(existingSaves);
      const saveSlot = saveSlots.find(s => s.id === slotId);
      
      if (!saveSlot) return false;
      
      // Ensure auto box office settings exist
      const loadedState = {
        ...saveSlot.gameState,
        autoBoxOfficeSettings: { 
          ...getDefaultAutoBoxOfficeSettings(), 
          ...(saveSlot.gameState.autoBoxOfficeSettings || {}) 
        }
      };
      
      setGameState(loadedState);
      setCurrentSaveSlot(slotId);
      localStorage.setItem(SAVE_KEY, JSON.stringify(loadedState));
      localStorage.setItem(CURRENT_SAVE_SLOT_KEY, slotId);
      
      return true;
    } catch (error) {
      console.error('Load failed:', error);
      return false;
    }
  }, []);

  const getSaveSlots = useCallback((): SaveSlot[] => {
    try {
      const existingSaves = localStorage.getItem(SAVE_SLOTS_KEY);
      return existingSaves ? JSON.parse(existingSaves) : [];
    } catch {
      return [];
    }
  }, []);

  const deleteSave = useCallback((slotId: string) => {
    try {
      const existingSaves = localStorage.getItem(SAVE_SLOTS_KEY);
      if (!existingSaves) return false;
      
      const saveSlots: SaveSlot[] = JSON.parse(existingSaves);
      const updatedSlots = saveSlots.filter(s => s.id !== slotId);
      
      localStorage.setItem(SAVE_SLOTS_KEY, JSON.stringify(updatedSlots));
      
      if (currentSaveSlot === slotId) {
        setCurrentSaveSlot('main');
        localStorage.setItem(CURRENT_SAVE_SLOT_KEY, 'main');
      }
      
      return true;
    } catch (error) {
      console.error('Delete save failed:', error);
      return false;
    }
  }, [currentSaveSlot]);

  const exportSave = useCallback((slotId?: string) => {
    try {
      const targetSlot = slotId || currentSaveSlot;
      const saveSlots = getSaveSlots();
      const saveSlot = saveSlots.find(s => s.id === targetSlot);
      
      if (!saveSlot) return null;
      
      const exportData = {
        version: SAVE_VERSION,
        exportDate: Date.now(),
        saveSlot
      };
      
      const dataStr = JSON.stringify(exportData, null, 2);
      const dataBlob = new Blob([dataStr], { type: 'application/json' });
      const url = URL.createObjectURL(dataBlob);
      
      const link = document.createElement('a');
      link.href = url;
      link.download = `entrepreneur-empire-save-${targetSlot}-${new Date().toISOString().split('T')[0]}.json`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
      
      return true;
    } catch (error) {
      console.error('Export failed:', error);
      return false;
    }
  }, [currentSaveSlot, getSaveSlots]);

  const importSave = useCallback((file: File): Promise<boolean> => {
    return new Promise((resolve) => {
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const importData = JSON.parse(e.target?.result as string);
          
          if (!importData.saveSlot || !importData.version) {
            resolve(false);
            return;
          }
          
          const newSlotId = `imported-${Date.now()}`;
          const importedSave: SaveSlot = {
            ...importData.saveSlot,
            id: newSlotId,
            name: `Imported - ${importData.saveSlot.name}`,
            lastPlayed: Date.now(),
            gameState: {
              ...importData.saveSlot.gameState,
              autoBoxOfficeSettings: { 
                ...getDefaultAutoBoxOfficeSettings(), 
                ...(importData.saveSlot.gameState.autoBoxOfficeSettings || {}) 
              }
            }
          };
          
          const existingSaves = getSaveSlots();
          existingSaves.push(importedSave);
          
          localStorage.setItem(SAVE_SLOTS_KEY, JSON.stringify(existingSaves));
          resolve(true);
        } catch (error) {
          console.error('Import failed:', error);
          resolve(false);
        }
      };
      reader.readAsText(file);
    });
  }, [getSaveSlots]);

  const newGame = useCallback(() => {
    const defaultState = getDefaultGameState();
    setGameState(defaultState);
    performSave(defaultState, 'main');
    setCurrentSaveSlot('main');
  }, [performSave]);

  // Game actions (keeping existing ones)
  const createCompany = useCallback((industryId: string, companyName: string) => {
    const industry = INDUSTRIES.find(i => i.id === industryId);
    if (!industry) return false;

    if (gameState.cash < industry.baseCost) return false;

    const newCompany: Company = {
      id: Date.now().toString(),
      name: companyName,
      industry: industry.name,
      level: 1,
      baseIncome: industry.baseIncome,
      currentIncome: industry.baseIncome,
      upgradeCost: industry.baseCost * 2,
      marketValue: industry.baseCost * 1.5,
      sharesOwned: 100,
      lastUpdate: Date.now(),
      description: industry.description,
      icon: industry.icon,
      isReal: false,
      totalBoxOfficeEarnings: 0,
      moviesProduced: 0,
      lastBoxOfficeHit: 0,
      lastProjectStart: 0
    };

    setGameState(prev => ({
      ...prev,
      cash: prev.cash - industry.baseCost,
      companies: [...prev.companies, newCompany]
    }));

    return true;
  }, [gameState.cash]);

  const upgradeCompany = useCallback((companyId: string) => {
    setGameState(prev => {
      const company = prev.companies.find(c => c.id === companyId);
      if (!company || prev.cash < company.upgradeCost) return prev;

      const updatedCompanies = prev.companies.map(c => {
        if (c.id === companyId) {
          const newLevel = c.level + 1;
          const newIncome = c.baseIncome * Math.pow(1.5, newLevel - 1);
          return {
            ...c,
            level: newLevel,
            currentIncome: newIncome,
            upgradeCost: Math.floor(c.upgradeCost * 1.8),
            marketValue: c.marketValue * 1.3
          };
        }
        return c;
      });

      return {
        ...prev,
        cash: prev.cash - company.upgradeCost,
        companies: updatedCompanies
      };
    });
  }, []);

  const buyShares = useCallback((companyId: string, percentage: number) => {
    setGameState(prev => {
      const company = prev.companies.find(c => c.id === companyId);
      if (!company) return prev;

      const cost = (company.marketValue * percentage / 100);
      if (prev.cash < cost || company.sharesOwned + percentage > 100) return prev;

      const updatedCompanies = prev.companies.map(c => 
        c.id === companyId 
          ? { ...c, sharesOwned: c.sharesOwned + percentage, marketValue: c.marketValue * 1.02 }
          : c
      );

      return {
        ...prev,
        cash: prev.cash - cost,
        companies: updatedCompanies
      };
    });
  }, []);

  const sellShares = useCallback((companyId: string, percentage: number) => {
    setGameState(prev => {
      const company = prev.companies.find(c => c.id === companyId);
      if (!company || company.sharesOwned < percentage) return prev;

      const revenue = (company.marketValue * percentage / 100) * 0.95; // 5% transaction fee

      const updatedCompanies = prev.companies.map(c => 
        c.id === companyId 
          ? { ...c, sharesOwned: c.sharesOwned - percentage, marketValue: c.marketValue * 0.98 }
          : c
      );

      return {
        ...prev,
        cash: prev.cash + revenue,
        companies: updatedCompanies
      };
    });
  }, []);

  const buyRealShares = useCallback((companyId: string, percentage: number) => {
    setGameState(prev => {
      const company = prev.realCompanies.find(c => c.id === companyId);
      if (!company) return prev;

      const cost = (company.marketValue * percentage / 100);
      if (prev.cash < cost || company.sharesOwned + percentage > 100) return prev;

      const updatedRealCompanies = prev.realCompanies.map(c => 
        c.id === companyId 
          ? { ...c, sharesOwned: c.sharesOwned + percentage, marketValue: c.marketValue * 1.01 }
          : c
      );

      return {
        ...prev,
        cash: prev.cash - cost,
        realCompanies: updatedRealCompanies
      };
    });
  }, []);

  const sellRealShares = useCallback((companyId: string, percentage: number) => {
    setGameState(prev => {
      const company = prev.realCompanies.find(c => c.id === companyId);
      if (!company || company.sharesOwned < percentage) return prev;

      const revenue = (company.marketValue * percentage / 100) * 0.98; // 2% transaction fee for real companies

      const updatedRealCompanies = prev.realCompanies.map(c => 
        c.id === companyId 
          ? { ...c, sharesOwned: c.sharesOwned - percentage, marketValue: c.marketValue * 0.995 }
          : c
      );

      return {
        ...prev,
        cash: prev.cash + revenue,
        realCompanies: updatedRealCompanies
      };
    });
  }, []);

  const formatCurrency = useCallback((amount: number) => {
    if (amount >= 1e12) return `$${(amount / 1e12).toFixed(2)}T`;
    if (amount >= 1e9) return `$${(amount / 1e9).toFixed(2)}B`;
    if (amount >= 1e6) return `$${(amount / 1e6).toFixed(2)}M`;
    if (amount >= 1e3) return `$${(amount / 1e3).toFixed(2)}K`;
    return `$${amount.toFixed(2)}`;
  }, []);

  const formatPlayTime = useCallback((seconds: number) => {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    
    if (hours > 0) {
      return `${hours}h ${minutes}m`;
    }
    return `${minutes}m`;
  }, []);

  const getCreditScoreLabel = useCallback((score: number) => {
    if (score >= 800) return 'Excellent';
    if (score >= 740) return 'Very Good';
    if (score >= 670) return 'Good';
    if (score >= 580) return 'Fair';
    return 'Poor';
  }, []);

  return {
    gameState,
    industries: INDUSTRIES,
    loanOffers: LOAN_OFFERS,
    saveStatus,
    currentSaveSlot,
    createCompany,
    upgradeCompany,
    buyShares,
    sellShares,
    buyRealShares,
    sellRealShares,
    formatCurrency,
    formatPlayTime,
    getCreditScoreLabel,
    // Save management
    manualSave,
    loadSave,
    getSaveSlots,
    deleteSave,
    exportSave,
    importSave,
    newGame,
    // Loan management
    takeLoan,
    repayLoan,
    // Box office management
    startBoxOfficeProject,
    updateAutoBoxOfficeSettings
  };
};